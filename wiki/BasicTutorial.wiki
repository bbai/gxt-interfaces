#summary This tutorial provides a simple overview for setting up and using the gxt-interfaces project.
#labels Phase-Implementation,Featured

== Motivation for creating the project ==
The main reason for creating and sharing this project is the *untestability* of the GXT visual components. In a nutshell, the GXT visual components cannot be mocked (via such frameworks as _Mockito_ or _EasyMock_), making any attempt to *test* the code (in the JVM) virtually impossible. 

This project essentially creates a very *thin layer* on top of GXT, in order to allow the client code to work with *interfaces* instead of the actual GXT classes. The benefits of working with interfaces (from the testing point of view) are huge: almost everything becomes testable. 


== Advantages (draft) ==
 * testing is fast (orders of magnitude faster then the GWTTestCase ones)
 * testing is done in the JVM, not in GWT, meaning that all the good mocking frameworks are now available
 * JUnit 4 can be used, instead of the very old JUnit 3 (GWT limitation)
 * the code is cleaner and more decoupled (using interfaces)


== Setup ==
 * include the gxt-interfaces jar on the classpath of your project (via manual inclusion, maven or some other type of dependency management)
 * inherit the GXTInterfaces module from within your application module (no package required)
`<inherits name='GXTInterfaces'/>`
 * done


== Usage and examples ==
- instead of: 
` Button button = new Button();`

use: 
` IButton button = new VButton();`

- or more generic: 
` IComponent button = new VButton();`



== Mocking ==
=== -with Mockito- ===

- mocking a button: 

`IButton buttonMock = Mockito.mock( IButton.class );`



== Test sample (draft) ==
{{{
@Test
public void serverCommunicationStarted_theActionButtonIsDisabled(){
   // Arrange
   final IButton buttonMock = Mockito.movck( IButton.class ); 

   // Act
   buttonMock.disable(); 

   // Assert
   Mockito.verify( buttonMock ).disable(); 
}
}}}